# Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
# SPDX-License-Identifier: Apache-2.0
"""
This file contains helper functions for updating the cache.
"""

import os
import time

import boto3
from botocore.exceptions import ClientError

import chalicelib.settings as msam_settings
import chalicelib.cloudwatch as cloudwatch_data
import chalicelib.connections as connection_cache
import chalicelib.nodes as node_cache
from chalicelib import content
from chalicelib.cache import regions

# table names generated by CloudFormation
ALARMS_TABLE_NAME = os.environ["ALARMS_TABLE_NAME"]
CONTENT_TABLE_NAME = os.environ["CONTENT_TABLE_NAME"]


def update_alarms():
    """
    Entry point for the CloudWatch scheduled task to discover and cache services.
    """
    try:
        print("update alarms")
        resource_cache = {}
        updated = int(time.time())
        ddb_table_name = ALARMS_TABLE_NAME
        ddb_resource = boto3.resource('dynamodb')
        ddb_table = ddb_resource.Table(ddb_table_name)
        for alarm in cloudwatch_data.all_subscribed_alarms():
            region = alarm["Region"]
            name = alarm["AlarmName"]
            if region in resource_cache:
                cloudwatch = resource_cache[region]
            else:
                cloudwatch = boto3.resource('cloudwatch', region_name=region)
                resource_cache[region] = cloudwatch
            alarm = cloudwatch.Alarm(name)
            region_alarm_name = "{}:{}".format(region, name)
            # look up the resources with this region alarm name
            subscribers = cloudwatch_data.subscribers_to_alarm(name, region)
            for resource_arn in subscribers:
                item = {
                    "RegionAlarmName": region_alarm_name,
                    "ResourceArn": resource_arn,
                    "StateValue": alarm.state_value,
                    "Namespace": alarm.namespace,
                    "StateUpdated": int(alarm.state_updated_timestamp.timestamp()),
                    "Updated": updated
                }
                ddb_table.put_item(Item=item)
    except ClientError as error:
        print(error)
    return True


def update_connections():
    """
    Entry point for the CloudWatch scheduled task to discover and cache services.
    """
    try:
        connection_cache.update_connection_ddb_items()
    except ClientError as error:
        print(error)
    return True


def update_nodes():
    """
    Entry point for the CloudWatch scheduled task to discover and cache services.
    """
    try:
        never_regions_key = "never-cache-regions"
        never_regions = msam_settings.get_setting(never_regions_key)
        if never_regions is None:
            never_regions = []
        settings_key = "cache-next-region"
        # make a region name list
        region_name_list = []
        for region in regions():
            region_name = region["RegionName"]
            # exclude regions listed in never-cache setting
            if region_name not in never_regions:
                region_name_list.append(region_name)
            else:
                print("{} in {} setting".format(region_name, never_regions_key))
        # sort it
        region_name_list.sort()
        # get the next region to process
        next_region = msam_settings.get_setting(settings_key)
        # start at the beginning if no previous setting
        if next_region is None:
            next_region = region_name_list[0]
        # otherwise it's saved for us
        region_name = next_region
        # store the region for the next schedule
        try:
            # process global after the end of the region list
            if region_name_list.index(next_region) + 1 >= len(region_name_list):
                next_region = "global"
            else:
                next_region = region_name_list[region_name_list.index(next_region) + 1]
        except (IndexError, ValueError):
            # start over if we don't recognize the region, ex. global
            next_region = region_name_list[0]
        # store it
        msam_settings.put_setting(settings_key, next_region)
        # update the region
        print("updating region {}".format(region_name))
        if region_name == "global":
            content.put_ddb_items(node_cache.s3_bucket_ddb_items())
            content.put_ddb_items(node_cache.cloudfront_distribution_ddb_items())
        else:
            node_cache.update_regional_ddb_items(region_name)
    except ClientError as error:
        print(error)
    return True
